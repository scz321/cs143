

## preparation

#### 评分

1. 下载评分脚本：

   ```
   CODE
   wget https://courses.edx.org/assets/courseware/v1/2aa4dec0c84ec3a8d91e0c1d8814452b/asset-v1:StanfordOnline+SOE.YCSCS1+1T2020+type@asset+block/pa1-grading.pl
   ```

   编译：

   ```
   CODE
   make lexer
   ```

   测试：

   ```
   CODE
   perl pa1-grading.pl
   ```



#### 报错处理

如果

```
SHELL
make lexer
```

产生如下报错：

```
CODE
/usr/bin/ld: /usr/lib/gcc/x86_64-linux-gnu/9/../../../x86_64-linux-gnu/libfl.so: undefined reference to `yylex' collect2: error: ld returned 1 exit status
```

那么在definitions和rules之间增加如下内容即可：

```
CODE
%option noyywrap
```

git push前：

```
git config --global http.proxy
git config --global https.proxy 
git config --global --unset http.proxy
git config --global --unset https.proxy

(windows需要管理员权限)

如果上面的方法不行，可以试下面的方法（同样需要管理员权限）
git config --global http.sslVerify false
git config --global https.sslVerify false
```

```
git push github_remote thread:thread --force
```

token:

```
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
```

###### 

## language specification

###### 使用正则语言和正则表达式来进行language specification

![image-20230914145348970](C:\Users\OrangeO_o\AppData\Roaming\Typora\typora-user-images\image-20230914145348970.png)

> 你如何理解下面这段话：The standard notation for regular languages is regular expressions.。请结合实例详细解释
>
> 
>
> ChatGPT
>
> 
>
> 这句话说的是，对于正则语言（Regular Languages），通常使用正则表达式（Regular Expressions）作为标准表示方法。
>
> 首先，我们来简单了解一下“正则语言”和“正则表达式”。
>
> 1. **正则语言 (Regular Languages)**: 在计算机科学和形式语言理论中，正则语言是一种特定类型的语言，可以由正则表达式描述或由有限自动机接受。正则语言的主要特点是它们的结构相对简单，并且可以通过计算机上的算法进行高效处理。
> 2. **正则表达式 (Regular Expressions)**: 正则表达式是一种字符串，用来描述一类特定模式的字符串集合。它们通常用于字符串搜索和替换操作，以及数据验证等场景。正则表达式本身有一套特定的语法，可以用来描述复杂的字符串模式。
>
> 现在，举一个实例来进一步解释：
>
> 假设我们想描述所有由三个字母组成的字符串模式。对应的正则表达式可以是：
>
> ```
> cssCopy code
> ^[a-zA-Z]{3}$
> ```
>
> 这个正则表达式可以分为以下部分进行解释：
>
> - `^`: 表示字符串的开始。
> - `[a-zA-Z]`: 表示一个字符，可以是任意的小写或大写字母。
> - `{3}`: 表示前面的模式（即一个字母）重复三次。
> - `$`: 表示字符串的结束。
>
> 所以，整个正则表达式描述的是：一个恰好由三个字母（不区分大小写）组成的字符串。
>
> 这种表达方式使得我们可以非常精确地描述和匹配特定的字符串模式。所以正则表达式成为了描述正则语言的标准表示方法。

对于下面五个规则的介绍，仅仅看课件不够，参阅视频后可以掌握,[链接](https://www.bilibili.com/video/BV17K4y147Bz?p=10&spm_id_from=pageDriver&vd_source=1fcac92e7e383d04d0f8eb7c835fa7cd)

![image-20230914161019777](C:\Users\OrangeO_o\AppData\Roaming\Typora\typora-user-images\image-20230914161019777.png)

![image-20230914161626392](C:\Users\OrangeO_o\AppData\Roaming\Typora\typora-user-images\image-20230914161626392.png)



- 为什么integer = digit digit*，而integer = digit`*`是不够的?

  > 因为digit*必然包括digit(0)={""}

## language implemention



啊？？ NFA->DFA也行？

> 确实是可以的：把NFA的一个eplsion闭包整体视为一个状态，且在此基础上发生的tansition都是非epsilon的。而且start state和final state也很好定义。
>
> 能看懂下面这张图即可：
>
> ![image-20230914195017621](C:\Users\OrangeO_o\AppData\Roaming\Typora\typora-user-images\image-20230914195017621.png)

![image-20230914163043854](C:\Users\OrangeO_o\AppData\Roaming\Typora\typora-user-images\image-20230914163043854.png)

正则表达式的notation略作改变：

![image-20230914163213806](C:\Users\OrangeO_o\AppData\Roaming\Typora\typora-user-images\image-20230914163213806.png)

###### NFA->DFA转换规则

主要是add transition的部分不太好理解，结合具体例子理解。

值得注意得的是，这里的iff的意思是充分必要条件的意思，也就是说，仅仅在这种case下才可以为新建的DFA新增一个transition

![image-20230914171555746](C:\Users\OrangeO_o\AppData\Roaming\Typora\typora-user-images\image-20230914171555746.png)



> 对于这段话中的any我不是很明确，它是否意味着，对于S‘中的任何一个状态，都可以由S中的任何一个状态在input为a的情况下得到？
>
> 
>
> 对于你提到的那段话，"any" 不意味着“对于`S'`中的任何一个状态，都可以由`S`中的任何一个状态在input为a的情况下得到”。
>
> 实际上，它的意思是：“存在一个状态在`S`中，当看到输入`a`时，可以到达`S'`中的某些状态”。
>
> 换句话说，只要`S`中的某个状态在输入`a`时可以到达`S'`中的任何状态（考虑到ε-moves），我们就会在DFA中为`S`和`S'`之间添加一个转换。

emmmm,感觉gpt的解释仍然不是很明确：

还是参考龙书的表述比较准确：S'是S在读入了某个输入串之后可能谓语的所有状态的集合

![image-20230914191105361](C:\Users\OrangeO_o\AppData\Roaming\Typora\typora-user-images\image-20230914191105361.png)

## parser



- 不是所有语言都是正则的

  > 我不太能理解下面这段话：Strings of balanced parentheses are not regular
  >
  > 
  >
  > ChatGPT
  >
  > 
  >
  > 这句话关于“平衡的括号的字符串不是正则的”需要一些形式语言理论的背景来理解。
  >
  > 首先，当我们谈论一个语言是“正则的”，我们指的是该语言可以由一个正则表达式描述，或者说可以由一个确定性有限自动机（DFA）或非确定性有限自动机（NFA）识别。
  >
  > 考虑一个语言L，其中包含所有的平衡的括号字符串。一个字符串被认为是平衡的，当且仅当它包含相同数量的打开括号`(`和关闭括号`)`，并且在任何字符串的前缀中，打开括号的数量都不少于关闭括号的数量。
  >
  > 例如：
  >
  > - `()` 是平衡的。
  > - `()()` 是平衡的。
  > - `(())` 是平衡的。
  > - `)(` 是不平衡的。
  > - `(()` 是不平衡的。****

DFA的不足：对于下面的DFA，它只能判断01字符串中1的数量是不是偶数个，但是不能判断1到达accepted state的次数。而对于诸如左右括号、if-else这种嵌套结构，其acceptd的状态的判断是以来于上面提到的”次数"的，这就引出了parse

![image-20230914200718585](C:\Users\OrangeO_o\AppData\Roaming\Typora\typora-user-images\image-20230914200718585.png)

parser vs lexer：

![image-20230914201228904](C:\Users\OrangeO_o\AppData\Roaming\Typora\typora-user-images\image-20230914201228904.png)

###### 上下文无关法

首先结合具体事例体会它的威力：

> 现在，来看一个具体的例子。
>
> 假设我们有以下的CFG，它描述了简单的平衡括号的字符串：
>
> ```
> S → (S)
> S → SS
> S → ε
> ```
>
> 其中，S是开始符号，ε表示空字符串，"("和")"是终结符。
>
> 使用这个CFG，我们可以生成如下的字符串：
>
> 1. **S → ε**: 这意味着空字符串是这个语言的一部分。
> 2. **S → (S) → ()**: 这表示字符串"()"是这个语言的一部分。
> 3. **S → SS → (S)S → (S)(S) → ()(S) → ()()**: 这表示字符串"()()"也是这个语言的一部分。
>
> 以上的例子都符合定义，即：从开始符号S出发，我们可以经过一系列的产生式得到一个仅由终结符组成的字符串。
>
> 因此，根据给定的定义，该CFG描述的语言是所有由这个CFG生成且仅由终结符组成的字符串的集合。

结合这个例子可以理解这句话：

> Let G be a context-free grammar with start symbol S. Then ==the language of G== is: {a1…an | S →* a1…an and every ai is a terminal }

同时你也可以理解start symbol存在的意义

> 我们常常写出下面的context-free gramer： Expr->id，这里Expr是表达式的意思，我想知道id的详细含义
>
> 
>
> ChatGPT
>
> 
>
> 在许多编译器和形式语言的文献中，`id` 通常是一个代表**标识符**（identifier）的缩写。标识符在编程语言中是一个非常常见的概念，它用于命名变量、函数、类型等。
>
> 在形式化语言和上下文无关文法（Context-Free Grammar, CFG）的描述中，`id` 是一个终结符，它代表源代码中的一个标识符。
>
> 例如，考虑以下的简单语法：
>
> ```
> bashCopy codeExpr -> id
>    | Expr + Expr
>    | ( Expr )
> ```
>
> 这个语法描述了一个简单的算术表达式，其中表达式可以是一个标识符，两个表达式通过加号连接，或者一个在括号中的表达式。
>
> 在这种情况下，`id` 可以代表任何有效的标识符，例如：`x`, `y`, `totalAmount`, `computeValue` 等。
>
> 在实际的编译器或解释器的实现中，通常会有更为复杂的规则来定义什么样的字符串序列构成一个有效的`id`。例如，在许多编程语言中，标识符必须以字母或下划线开头，后跟字母、数字或下划线。这些具体的词法规则通常是通过词法分析器（lexer）来实施的，而不是在CFG中明确指定的。



> 按照你的说法，纯数字，比如37并不能算作一个标识符，这就意味着37+37并不符合上述要求？
>
> 
>
> ChatGPT
>
> 
>
> 你是对的，基于我先前给出的简化语法，表达式`37 + 37`确实不符合那个语法，因为`37`不是一个标识符（`id`）。
>
> 在许多实际的上下文无关文法中，你会看到对数字（如整数、浮点数等）有明确的定义。例如，我们可以扩展上述语法，使其更加完整：
>
> ```
> scssCopy codeExpr   -> id
>     | num
>     | Expr + Expr
>     | ( Expr )
> 
> id     -> [a-zA-Z_][a-zA-Z0-9_]*
> num    -> [0-9]+
> ```
>
> 在这个扩展的语法中，`id`仍然代表标识符，而新添加的`num`代表数字。`[a-zA-Z_]`和`[a-zA-Z0-9_]*`这样的正则表达式定义了标识符的模式。`[0-9]+`定义了至少一个数字组成的数字模式。
>
> 这样，表达式`37 + 37`就满足这个扩展后的语法了，因为`37`被视为一个数字（`num`），而不是标识符。



截至目前，我们能做的仅仅是判断yes or no：==目前只能够判断a string of tokens是否属于某一种由CFG定义的语言==，但是这距离我们得出语法树还是有相当的距离的。

因此，我们下面要做的工作是：对于某一个EXPR，在判断为yes的基础上，对它进行derivation，得到一个parse tree。

这里又会引出一个问题，对于一个判定结果为yes的EXPR，我们可以由多种方式（一般使用left-most/right-most进行解析）进行derivation得到它，那么，不同的derivation过程就对应着不同的parse tree吗？还是说对于对于一个判定结果为yes的EXPR，其parse tree一定是固定的?



答案是否定的，考虑下面的例子：

> ![image-20230914223153278](C:\Users\OrangeO_o\AppData\Roaming\Typora\typora-user-images\image-20230914223153278.png)
>
> 对于同一个expr，我们按照下面展示的CFG，将会解析出两种不同的parse tree，这不是编译器希望看到的
>
> ![image-20230914223304995](C:\Users\OrangeO_o\AppData\Roaming\Typora\typora-user-images\image-20230914223304995.png)



这就引出了`ambiguous` grammar的概念了

解决方法：

- 写出更优雅的grammar：（most used)

  > ![image-20230914223825155](C:\Users\OrangeO_o\AppData\Roaming\Typora\typora-user-images\image-20230914223825155.png)
  >
  > - 仔细体会一下这个优化后的grammar，它实现了一个效果：所有的加法都必须在乘法之前被先进行分解，换言之，感觉它从某种程度上实现了乘法和加法的运算优先级的问题

- 另一种方法：（由于使用anbiguous的模式更贴近自然）现在许多编译器都使用这种更自然的方法，在出问题时（出现==二义性==时）再进行特殊处理（with disambiguation delarations)。

eg:下面的原来的grammar具有二义性，但是新增了Left assosiativity declarition之后就明确了：

> ![image-20230915113501957](C:\Users\OrangeO_o\AppData\Roaming\Typora\typora-user-images\image-20230915113501957.png)

## PA2

首先，需要学习flex的相关知识,以下面的示例程序为例，说明一些注意点：

```cpp
 /* scanner for a toy Pascal-like language */

    %{
    /* need this for the call to atof() below */
    #include <math.h>
    %}

    DIGIT    [0-9]
    ID       [a-z][a-z0-9]*

    %%

    {DIGIT}+    {
                printf( "An integer: %s (%d)\n", yytext,
                        atoi( yytext ) );
                }

    {DIGIT}+"."{DIGIT}*        {
                printf( "A float: %s (%g)\n", yytext,
                        atof( yytext ) );
                }

    if|then|begin|end|procedure|function        {
                printf( "A keyword: %s\n", yytext );
                }

    {ID}        printf( "An identifier: %s\n", yytext );

    "+"|"-"|"*"|"/"   printf( "An operator: %s\n", yytext );

    "{"[^{}\n]*"}"     /* eat up one-line comments */

    [ \t\n]+          /* eat up whitespace */

    .           printf( "Unrecognized character: %s\n", yytext );

    %%

    int main( int argc, char **argv )
        {
        ++argv, --argc;  /* skip over program name */
        if ( argc > 0 )
                yyin = fopen( argv[0], "r" );
        else
                yyin = stdin;

        yylex();
        }
```

- 对于正则表达式的匹配，存在如下规则：

  > "x"    :     an ”x”, even if x is an operator.

​	这里其实容易引发歧义，主要是对于operator的理解,这里的operator是指正则表达式中的operator，而不是Expression中的operator，加双引号的意义就在	于此。比如+号在正则表达式和算术运算中有着不同的意义

> 在 `flex` 中，当正则表达式用双引号包围时，它通常表示字符串中的字面值。这意味着它会尝试匹配输入中的确切字符序列，而不是正则表达式中可能表示的特殊字符。
>
> 因此，当你在 `flex` 规则中写：
>
> ```
> flexCopy code
> "+"  { /* action for the + character */ }
> ```
>
> 这意味着它将匹配输入中的实际 `+` 字符，而不是正则表达式中的其他特殊意义（例如，`+` 在正则表达式中通常表示“一个或多个前面的元素”）。
>
> 因此，对于你的问题："x" an ”x”, even if x is an operator。这句话的意思是，即使 `x` 是一个正则表达式的操作符，当它被双引号包围时，它将被识别为字面字符 `x` 而不是操作符。

- 上面的规则定义中，最后有一条：

  ```
      .           printf( "Unrecognized character: %s\n", yytext );
  ```

  这里利用到了规则定义中的一个特性，或者说是yylex函数执行时的一个特性：==按照从前到后的顺序进行匹配，一旦匹配到符合条件的就停止匹配。==也就是说，这些规则的先后顺序本质上就是他们的优先级顺序。

> 这里我的理解其实不是很准确，因为我只考虑到了顺序原则：
>
> 
>
> 在flex定义的规则中，当输入的文本可以被多个模式匹配时，flex遵循以下的规则：
>
> 1. **==最长匹配原则==**：flex会选择与输入文本匹配最长的那个模式。例如，如果输入是"ab"，而规则中有模式"a"和"ab"，则会选择"ab"这个模式。
> 2. **==顺序原则==**：如果有多个模式与输入文本匹配的长度相同，flex会选择在文件中出现最早的那个模式。例如，如果规则文件中先定义了模式"a"，然后是模式"ab"，当输入为"ab"时，尽管两个模式都可以匹配，但flex会选择第一个模式"a"。
>
> 所以，在你提到的那条规则中：
>
> ```
> perlCopy code
> .           printf( "Unrecognized character: %s\n", yytext );
> ```
>
> `.` 这个模式会匹配任何单个字符。因为它是规则文件中的最后一条，所以只有当输入的文本没有被前面的任何模式匹配时，这条规则才会生效。这确保了任何未被其他规则识别的字符都会被这条规则捕获并输出错误消息。这是一个常见的模式，用于报告扫描器中的词法错误。

### Definitions Section

The definition can subsequently be referred to using ‘{name}’, which will expand to ‘==(definition)==’. For example：

定义：

```
DIGIT    [0-9]
ID       [a-z][a-z0-9]*
```

那么在规则部分，

```
{DIGIT}+"."{DIGIT}*
```

就等价于：

```
([0-9])+"."([0-9])*
```

### User Code Section

The user code section is simply copied to lex.yy.c verbatim. It is used for companion routines which call or are called by the scanner. The presence of this section is ==optional==; if it is missing, the second ‘%%’ in the input file may be skipped, too.

> 所以说，对于我自己定义的rule.flex文件，我必须要定义一个main函数，并且在其中调用yylex()，对吗？
>
> 
>
> ChatGPT
>
> 
>
> 不完全是。你是否需要在 `.flex` 文件中定义一个 `main` 函数取决于你的用例和扫描器如何与其他代码协同工作。
>
> 1. **如果 `.flex` 文件是独立的**: 如果你想要生成一个独立的扫描器程序，那么你确实需要在 `.flex` 文件中定义一个 `main` 函数并在其中调用 `yylex()`。这样，当你生成、编译并运行扫描器时，它会开始读取输入，并按照定义的规则进行匹配。
> 2. **与其他代码集成**: 如果你的扫描器是与其他代码（例如 Bison 生成的解析器）一起工作的，那么你可能不需要在 `.flex` 文件中定义 `main` 函数。在这种情况下，其他代码可能会负责调用 `yylex()`。
> 3. **默认的 `main` 函数**: 如果你没有为 `.flex` 文件提供 `main` 函数，`flex` 会为生成的 C 代码提供一个默认的 `main` 函数，这个函数简单地调用 `yylex()` 并返回。这可以方便地用于测试扫描器。
>
> 总之，你是否需要在 `.flex` 文件中定义一个 `main` 函数取决于你的需求。如果你只是想测试扫描器，使用默认的 `main` 函数或自己定义一个就足够了。如果你的扫描器是与其他系统集成的一部分，你可能需要确保适当的代码调用了 `yylex()`。

### Patterns

> \X’
>
> ==if== X is ‘a’, ‘b’, ‘f’, ‘n’, ‘r’, ‘t’, or ‘v’, then the ANSI-C interpretation of ‘\x’. ==Otherwise==, a literal ‘X’ (used to escape operators such as ‘*’)

### 实验细节

- 其实它已经帮你做了很多了——先后顺序已经排好了，这意味着优先级顺序不需要列入我们的考虑范围之内，我们只需要专注于正则表达式的匹配即可

- 在cool-parse.h中，搞清楚美剧类型的yytokentype和YYSTYPE之间的关系：

  首先给出两者的定义：

```
#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
typedef union YYSTYPE
#line 46 "cool.y"
{
  Boolean boolean;
  Symbol symbol;
  Program program;
  Class_ class_;
  Classes classes;
  Feature feature;
  Features features;
  Formal formal;
  Formals formals;
  Case case_;
  Cases cases;
  Expression expression;
  Expressions expressions;
  char *error_msg;
}
/* Line 1489 of yacc.c.  */
#line 124 "cool.tab.h"
	YYSTYPE;
# define yystype YYSTYPE /* obsolescent; will be withdrawn */
# define YYSTYPE_IS_DECLARED 1
# define YYSTYPE_IS_TRIVIAL 1
#endif

```

- 关于字符串+换行:其匹配规则为：

  ```cpp
  /* 换行 */
  <STRING>\\\n                                                    {
                                                                      curr_lineno++;
                                                                      yymore();
                                                                  }
  ```

  而不是你想当然认为的<STRING>\n

  事实上，匹配到\n是会报错的！

  ```cpp
  <STRING>\n                                                      {
                                                                      cool_yylval.error_msg = "Unterminated string constant";
                                                                      curr_lineno++;
                                                                      BEGIN 0;
                                                                      return ERROR;
                                                                  }
  ```

  以c语言举例：

  ![image-20230916001203258](C:\Users\OrangeO_o\AppData\Roaming\Typora\typora-user-images\image-20230916001203258.png)

![image-20230916001341763](C:\Users\OrangeO_o\AppData\Roaming\Typora\typora-user-images\image-20230916001341763.png)

> - 使用`BEGIN(STRING);`切换到`STRING`状态，这意味着从此时开始，只有标记为`<STRING>`的模式会被考虑匹配。
> - 使用`yymore();`，这个函数是Flex提供的，它的意思是将下一个识别到的文本追加到`yytext`中，而不是替换它。

- 整数/标识符

- 这里就涉及你对于string table结构体的master了

  > 对于下面的规则。把标识符添加到stringtable中我可以理解，但是为什么对于简单的证书也要将它添加到相应的inttable中？：{DIGIT}+                                                        

  ```cpp
  {DIGIT}+                                                        {   
                                                                      cool_yylval.symbol = 																								inttable.add_string(yytext);
                                                                      return INT_CONST;
                                                                  }
  
  
  [A-Z][0-9a-zA-Z_]*                                              {
                                                                      cool_yylval.symbol = 																								idtable.add_string(yytext);
                                                                      return TYPEID;
                                                                  }
  
  [a-z][0-9a-zA-Z_]*                                              {   
                                                                      cool_yylval.symbol = 																								idtable.add_string(yytext);
                                                                      return OBJECTID;
                                                                  }
  
  ```

  > ChatGPT
  >
  > 在编译器设计中，把数字常量、标识符、类型标识符等加入到各自的表格中的做法是常见的。理由如下：
  >
  > 1. **唯一性和重用**: 将词素（如数字、标识符）添加到表中确保了只为源代码中的每个不同的词素保存一个实例。例如，假设源代码中的数字`123`出现了多次，那么`inttable`中只存储一次`123`。这可以节省内存，并使得之后对这个数字的所有引用都指向同一个地方。
  > 2. **高效的相等性检查**: 当从表中检索或比较值时，不需要对整个字符串进行字符逐字符的比较。由于每个词素在表中都是唯一的，因此可以简单地比较其指针或索引。
  > 3. **额外的信息存储**: 通常，当向这样的表中添加一个项时，除了字符串本身，还可以关联其他信息。例如，可以为每个项分配一个唯一的索引号，或者关联有关该项的附加数据。
  > 4. **代码生成**: 在代码生成阶段，特别是在目标代码或汇编代码的生成中，这些表格为常量提供了方便的管理方式。例如，为每个`inttable`中的数字生成全局数据段中的一个项。
  > 5. **错误检测和调试**: 当编译器发现一个错误或当你在调试模式下运行编译器时，这些表提供了一种简便的方法来引用、打印或处理词素。
  >
  > 考虑这样一个情境：假设你在编译的源代码中有一个大型数组，其所有元素都被初始化为相同的整数值`12345`。如果不使用`inttable`，则每次出现这个数字时，编译器都必须为其分配新的内存，并重复存储同样的字符序列。但是，使用`inttable`，这个数字只存储一次，并为所有其他出现重复使用同一个表项。这不仅节省了内存，而且使得在语义分析和代码生成阶段处理这个数字更为高效。



> 在前面的代码中，解释code_string_table的作用？
>
> 
>
> ChatGPT
>
> 
>
> 在给出的代码中，`code_string_table`是`StrTable`和`IntTable`类的成员函数，但没有给出其具体实现，因此我们只能基于函数名和一般编译器设计的经验来推测其作用。
>
> 在编译器的上下文中，`code_string_table`可能用于==生成目标代码或中间表示==，以定义或引用字符串表或整数表中的项。由于字符串和整数常量在运行时需要特定的内存布局或位置，因此这样的函数用于生成这些布局的代码。
>
> 这是一个简化的例子来解释其可能的作用：
>
> 假设我们有以下的源代码：
>
> ```
> coolCopy codeclass Main inherits IO {
>     main() : IO {
>         out_string("Hello, World!")
>     };
> };
> ```
>
> 在这里，字符串"Hello, World!"需要在运行时被存储在某个位置。编译器首先会将其添加到`stringtable`中。接着，在代码生成阶段，它需要为这个字符串生成数据定义。
>
> 一个简化的汇编代码片段可能如下：
>
> ```
> assemblyCopy code.data
> string_1: .asciiz "Hello, World!"
> ```
>
> `code_string_table`函数可能会负责生成上述汇编代码片段，将所有`stringtable`中的字符串都转换为这种格式的数据定义。
>
> 同样地，对于整数表`inttable`，函数可能会生成整数常量的数据定义。
>
> 总之，`code_string_table`函数可能是用于生成存储在表中的常量的目标代码或中间表示的。但没有具体的函数实现或文档，我们只能推测其精确的作用。



> 我注意到，对于IdTable，并没有这个方法
>
> 
>
> ChatGPT
>
> 
>
> 是的，从你提供的代码来看，确实只有`StrTable`和`IntTable`有`code_string_table`方法，而`IdTable`没有。
>
> 这个设计选择有一定的道理：
>
> 1. **字符串和整数常量需要数据存储**：字符串（如"Hello, World!"）和整数常量（如123）在运行时都需要一个特定的内存位置。这是因为它们是程序的实际数据，所以需要为它们分配存储空间，并在生成的代码中引用这些位置。因此，对于这两种类型的表，我们需要一个方法来生成这些数据的定义。
> 2. **标识符不需要数据存储**：相反，标识符（如变量名、类名或函数名）通常不存储为数据。而是在编译时被转换为某种引用（如内存地址、寄存器或其他编译器生成的标识符）。因此，标识符本身不需要在运行时的数据段中有一个位置。这解释了为什么`IdTable`不需要一个`code_string_table`方法：我们不需要为标识符生成数据定义。
>
> 这种区别是基于编译器如何处理不同种类的符号。字符串和整数常量被视为数据，需要在程序的数据段中分配存储空间；而标识符在编译过程中有不同的处理方式，通常它们的名字在运行时不直接出现，因此不需要生成对应的数据定义。

- operator

  - multiple-character operator和single-character operator的本质区别：

    > /*这里有一个巧妙的设计，对于ASCII码中已经定义的字符集，直接返回，就是它的“值”，而
    > 对于multiple-character operators，就必须要返回自己预先定义的一些值，比如256，257.
    > 这样就实现了=>和=在semantics层面的一致性*/   同样的，关键字的返回值也是基于此，实现了semantically-equal

- 由于这些匹配规则的先后顺序也很重要，所以说，出问题了也要想想是不是顺序没有排对。

- 盘点一些逆天bug：

  > ![image-20230916012700780](C:\Users\OrangeO_o\AppData\Roaming\Typora\typora-user-images\image-20230916012700780.png)

- lexer的工作原理：

  > 所以说，我的lexer是针对我写的每一条rule生成一个DFA，还是综合所有的rule生成一个总的DFA？
  >
  > 
  >
  > ChatGPT
  >
  > 
  >
  > ==综合所有的规则生成一个总的DFA。==
  >
  > 具体地说，词法分析器生成工具（例如Flex）通常按照以下步骤工作：
  >
  > 1. **生成NFA**：针对每一个提供的规则（正则表达式），工具会首先为每一个单独的规则生成一个NFA。
  > 2. **合并NFA**：所有这些单独的NFA被组合成一个大的NFA。这可以通过创建一个新的初始状态并从这个状态向每一个规则对应的NFA的初始状态添加ε（空）转移来完成。
  > 3. **从NFA到DFA**：接着，这个大的NFA被转换为DFA。这是通过所谓的“powerset构造法”或“子集构造法”完成的。这个过程可能会生成大量的状态，但每个状态都明确地表示一个特定的字符输入应该如何转移。
  > 4. **状态最小化**：为了使DFA更高效，它会被最小化，以确保它没有冗余的状态。
  >
  > 在执行阶段，词法分析器使用这个总的DFA来匹配输入的字符序列。当它进入一个接受状态（即一个状态代表一个有效的记号结束）时，它会查看是哪条规则首先匹配并执行该规则的关联动作。
  >
  > 由于是总的DFA，它可以在单次扫描中处理所有的规则。这使得DFA驱动的词法分析器非常高效，因为它只需为每个输入字符执行一次状态转移。

  > 你的意思是，词法分析器只要遇到accepted state，就会停止对DFA的遍历，把当前的结果从input'中提取出来？但是这会不会导致不满足最长匹配原则
  >
  > 
  >
  > ChatGPT
  >
  > 
  >
  > 你指出了一个重要的问题，即"最长匹配原则"。我的上一次解释可能有些简化，确实没有涉及这一点。让我们进一步探讨这个问题。
  >
  > 你是对的，DFA在遇到accepted state时不会立即停止。实际上，词法分析器通常使用贪婪匹配策略，尝试找到最长的匹配。
  >
  > 为了说明这一点，我们再考虑一个简单的例子：
  >
  > 规则：
  >
  > 1. `if`
  > 2. `[a-z]+` (匹配任意小写字母串)
  >
  > 现在，如果输入是"ifelse"：
  >
  > - 一个简单的DFA可能在读取"if"时即刻认为已找到一个匹配（即关键字"if"）。
  > - 但根据最长匹配原则，它应该继续读取，因为"ifelse"也符合第二个规则，即一个由小写字母组成的字符串。
  >
  > 因此，词法分析器的工作方式如下：
  >
  > 1. 它会==持续读取，直到没有更多的转移可以接受更多的输入为止==。
  > 2. 然后它==回溯==到上一个accepted state，并返回该状态对应的token。
  >
  > 在上面的例子中，DFA会在读完"ifelse"后停止，但它会回溯到"if"并返回关键字`if`的token，因为规则1在规则列表中出现得比规则2早。
  >
  > 这就是词法分析器如何确保遵循最长匹配原则的。同时，当有多个规则都可以匹配同一个字符串时，它会选择规则列表中最早的那个规则。

- 关于返回的类型和值：

  > 下面是我截取的部分规则：我发现，对于每一个keyword或者是oprator，我是仅仅返回其type，而且每一个不同的operator的返回type都不一样，但是对于字符串，我们在返回时区分它们的值，返回相同的type，为什么会有这种差异？
  >
  > 
  >
  > ChatGPT
  >
  > 
  >
  > 你提到了词法分析器处理关键字、运算符和字面量（如字符串、数字）时的两种不同策略。这两种策略之间的差异源于这些token的语义和用途。让我们一一分析：
  >
  > 1. **关键字和运算符**:
  >    - 关键字（如`if`、`while`）和运算符（如`+`、`-`）在大多数编程语言中具有固定的含义。==对于编译器来说，识别这些token的确切类型就足够了==，因为它们的语义是明确的。
  >    - 举个例子，关键字`if`在源代码中的出现表示一个条件语句的开始。编译器只需要知道遇到了一个`if`关键字，而不需要关心它的“值”。
  >    - 同理，对于运算符，识别出是哪个运算符就足够了（例如`+`、`-`、`*`等）。
  > 2. **字面量**:
  >    - 字面量，如字符串、整数和浮点数，有一个与之关联的值。这个值对于后续的编译步骤（例如语义分析和代码生成）是非常重要的。
  >    - 例如，字符串`"hello"`和`"world"`都是字符串，但它们的值是不同的。因此，虽然它们都是`STR_CONST`类型，但它们的具体值是必要的。
  >    - 同样，数字`42`和`100`都是整数，但它们的值也是不同的。
  >
  > 为了解决这个问题，大多数编译器的词法分析器将为每个token返回两部分信息：
  >
  > 1. **Token类型**：这告诉编译器这是什么样的token（例如，关键字、运算符、字符串、整数等）。
  > 2. **Token的属性值**：这对于字面量是必需的，表示该token的实际值（例如，字符串的内容或整数的数值）。
  >
  > 在你提供的例子中，关键字和运算符只返回其类型，因为它们的值对编译器的后续步骤没有意义。但对于像字符串这样的字面量，返回其类型和值都是必要的。

- 这个PA的扣分全在COMMET的部分，尤其要注意的是对于“全局状态”的把握，一般来说，写出下面的规则是很危险的;它表示在任何状态下你遇到(*字符都会进入COMMENT状态，那么，如果是在STRING状态呢hhh

```
"(*"       {cmt_depth++;BEGIN(COMMENT);}
```

- 正确的写法见源代码
- 总之做PA2的一个很大收获在于体会到了使用%x 定义的这些状态的妙用，以及对源码有了一个初步的认识

![image-20230916121253223](C:\Users\OrangeO_o\AppData\Roaming\Typora\typora-user-images\image-20230916121253223.png)

